# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T19:02:59+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Header, Path, Query, UploadFile
from pydantic import AnyUrl, conint

from models import (
    AccountPatchRequest,
    AccountResponse,
    Action1,
    EmailListCollectionResponse,
    EmailListResponse,
    EmailListsIdPatchRequest,
    EmailListsPostRequest,
    EmailReferralPostRequest,
    EmptyResponse,
    FormEntryResponse,
    FormResponse,
    FormsIdPatchRequest,
    Include,
    Include2,
    NotificationCollectionResponse,
    NotificationResponse,
    NotificationsIdPatchRequest,
    NotificationsPostRequest,
    PreviewFileResponse,
    RecipientsSharesInvitesShareIdPostRequest,
    ResourceCollectionResponse,
    ResourceCopyMove,
    ResourceMultiResponse,
    ResourceResponse,
    Resources1,
    ResourcesCompressPostRequest,
    ResourcesCopyPostRequest,
    ResourcesDeleteRequest,
    ResourcesExtractPostRequest,
    ResourcesIdPatchRequest,
    ResourcesMovePostRequest,
    ResourcesPostRequest,
    Scope,
    SessionActivityResponse,
    ShareCollectionResponse,
    ShareRecipientsResponse,
    ShareResponse,
    SharesIdPatchRequest,
    SharesPostRequest,
    Size,
    Sort,
    SSHKeyCollectionResponse,
    SSHKeyResponse,
    SshKeysPostRequest,
    Type22,
    Type25,
    UserCollectionResponse,
    UserResponse,
    UsersIdPatchRequest,
    UsersPostRequest,
    WebhookActivityResponse,
    WebhookCollectionResponse,
    WebhookResponse,
    WebhooksIdPatchRequest,
    WebhooksPostRequest,
)

app = MCPProxy(
    contact={'email': 'support@exavault.com', 'name': 'ExaVault Support'},
    description='ExaVaults API allows you to incorporate ExaVaults suite of file transfer and user management tools into your own application.\\nExaVault supports both POST (recommended when requesting large data sets) and GET operations, and requires an API key in order to use.',
    title='ExaVault',
    version='2.0',
    servers=[
        {
            'description': 'Replace accountname with your account name',
            'url': 'https://accountname.exavault.com/api/v2',
        }
    ],
)


@app.get(
    '/account',
    description=""" Get settings for your account, such as current space usage, webhooks settings, welcome email content and IP address restrictions. """,
    tags=['account_settings_management', 'user_operations_management'],
)
def get_account(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    include: Optional[str] = None,
):
    """
    Get account settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/account',
    description=""" Update account settings, such as welcome email content, IP address restrictions, webhooks settings and secure password requirements.

**Notes**

- You must have [admin-level access](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) to change account settings. """,
    tags=['account_settings_management', 'user_operations_management'],
)
def update_account(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: AccountPatchRequest = None,
):
    """
    Update account settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/activity/session',
    description=""" Returns the detailed activity logs for your account. Optional query paramaters will filter the returned results based on a number of options including usernames, activity types, or date ranges. 

**NOTE:** Total Results will always return as 0 to avoid quering data you're not using and stay as performant as possible. 
  
**Operation Types**
Session activity is logged with an operation type that is different from what is visible through the [activity log interface in the web file manager](/docs/account/10-activity-logs/00-activity-logs). Consult the table below to compare the two:

| File Manager Value | API Value | Notes |
|-----|----|---|
| Connect | PASS | |
| Disconnect | EXIT | |
| Upload | STOR | |
| Download | RETR | |
| Delete | DELE | |
| Create Folder | MKD | |
| Rename | RNTO | |
| Move | MOVE | |
| Copy | COPY | |
| Compress | COMPR | |
| Extract | EXTRACT | |
| Shared Folders | SHARE | |
| Send Files | SEND | |
| Receive Files | RECV | |
| _N/A_ | EDIT\_SEND | Update send. Not shown in file manager |
| Update Share | EDIT\_SHARE| | 
| Update Receive | EDIT\_RECV | |
| Delete Send | DELE\_SEND | |
| Delete Receive | DELE\_RECV | |
| Delete Share | DELE\_SHARE | |
| Create Notification | NOTIFY | |
| Update Notification | EDIT\_NTFY| |
| Delete Notification | DELE\_NTFY | |
| Create User | USER | |
| Update User | EDIT\_USER | |
| Delete User | DELE\_USER | |
| _N/A_ | DFA | Create direct link. Not shown in file manager |
| _N/A_ | EDIT\_DFA | Update direct link options. Not shown in file manager |
| _N/A_ | DELE\_DFA | Deactivate direct link. Not shown in file manager|
 """,
    tags=['user_session_logging'],
)
def get_session_logs(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    start_date: Optional[datetime] = Query(None, alias='startDate'),
    end_date: Optional[datetime] = Query(None, alias='endDate'),
    ip_address: Optional[str] = Query(None, alias='ipAddress'),
    username: Optional[str] = None,
    path: Optional[str] = None,
    type: Optional[str] = None,
    offset: Optional[int] = None,
    limit: Optional[int] = None,
    sort: Optional[str] = None,
):
    """
    Get activity logs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/activity/webhooks',
    description=""" Returns the webhook logs for your account. Use the available query parameters to filter the listing of activity that is returned.

**NOTE:** Total Results will always return as 0 to avoid querying data you're not using and stay as performant as possible. 

**Event Types**

Webhooks are triggered by enabled event types for your account, which are configured on the [developer settings page](/docs/account/09-settings/06-developer-settings). Not all event types may be allowed for your account type. These are the valid options for event types:

- resources.upload
- resources.download
- resources.delete
- resources.createFolder
- resources.rename
- resources.move
- resources.copy
- resources.compress
- resources.extract
- shares.formSubmit
 """,
    tags=['user_session_logging', 'webhook_operations_management'],
)
def get_webhook_logs(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    start_date: Optional[datetime] = Query(None, alias='startDate'),
    end_date: Optional[datetime] = Query(None, alias='endDate'),
    endpoint_url: Optional[AnyUrl] = Query(None, alias='endpointUrl'),
    event: Optional[str] = None,
    status_code: Optional[int] = Query(None, alias='statusCode'),
    resource_path: Optional[str] = Query(None, alias='resourcePath'),
    username: Optional[str] = None,
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[int] = None,
    sort: Optional[str] = None,
):
    """
    Get webhook logs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/email-lists',
    description=""" List all email groups for authenticated user """,
    tags=['email_list_management'],
)
def get_email_lists(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    include: Optional[str] = None,
):
    """
    Get all email groups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/email-lists',
    description=""" Create a new email list. Among other things, email lists can be used to send files or share folders with a group of email addresses at once. """,
    tags=['email_list_management'],
)
def add_email_list(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: EmailListsPostRequest = None,
):
    """
    Create new email list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/email-lists/{id}',
    description=""" Permanently delete an email group. This action is not reversible. We recommend making a user confirm this action before sending the API call.  """,
    tags=['email_list_management'],
)
def delete_email_list_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
):
    """
    Delete an email group with given id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/email-lists/{id}',
    description=""" Retrieve all the details of a specific email list including it's name, when it was created and all the email addresses that belong to the group. """,
    tags=['email_list_management'],
)
def get_email_list_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
    include: Optional[str] = None,
):
    """
    Get individual email group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/email-lists/{id}',
    description=""" Add or remove emails from an email list that can be used to send and share files with groups. 

**Notes**

*This call will **replace** your current email list in its entirety.* If you want to keep any existing emails on the list, be sure to submit the call with any current emails you want to keep on the list.   """,
    tags=['email_list_management'],
)
def update_email_list_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
    body: EmailListsIdPatchRequest = None,
):
    """
    Update an email group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/email/referral',
    description=""" Invite a friend to sign up for a free trial of ExaVault. Send a [referral](/lp/referafriend/) email to an email address. If the recipient signs up for ExaVault, we'll apply a credit to your account for the referral.  """,
    tags=['email_list_management'],
)
def send_referral_email(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: EmailReferralPostRequest = None,
):
    """
    Send referral email to a given address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/email/welcome/{username}',
    description=""" Send a welcome email to a user. The contents of the welcome email can be set by [PATCH /accounts](#operation/updateAccount). """,
    tags=['user_operations_management'],
)
def send_welcome_email(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    username: str = ...,
):
    """
    Resend welcome email to specific user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/forms',
    description=""" Get the information for the [file upload form](/docs/account/05-file-sharing/05-form-builder) assigned to a [receive folder](/docs/account/05-file-sharing/04-receive-folders) by its shareHash. The form details will return all the input field settings and the CSS for the form.

Use the `include` parameter (with the value **share**) to also get the details of the associated receive folder.

**Note**

- If you prefer to find a form by its ID, you can use the [GET /forms/{id}](#operation/getFormById) endpoint instead. 
 """,
    tags=['account_settings_management', 'form_submission_handling'],
)
def get_form_by_share_hash(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    share_hash: str = Query(..., alias='shareHash'),
    include: Optional[Include] = None,
):
    """
    Get receive folder form settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/forms/entries/{id}',
    description=""" Deletes a form submission entry, which represents one time that a visitor filled out the form and uploaded files. This deletes only the record of the submission (the date, the values entered in the form and the names of the files uploaded by the visitor).The share and any associated file resources will not be deleted by this. 

**Notes**:

- Use the [GET /form/entries/{formId}](#operation/getFormMessageById) to list the submissions and obtain the ID of the entry you want to delete
- You must have the [DeleteFormData permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) in order to use this operation
- It is not possible to un-delete data that is removed in this way
 """,
    tags=['form_submission_handling'],
)
def delete_form_message_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
):
    """
    Delete a receive form submission
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/forms/entries/{id}',
    description=""" Returns the form data entries for a specific form for a receive. Optional parameters can be included in the call to manage larger data sets.
 """,
    tags=['form_submission_handling'],
)
def get_form_entries(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
):
    """
    Get form data entries for a receive
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/forms/{id}',
    description=""" Returns the [file upload form](/docs/account/05-file-sharing/05-form-builder) assigned to a [receive folder](/docs/account/05-file-sharing/04-receive-folders). The form details will return all the input fields and their settings. 

Use the `include` parameter (with the value **share**) to also retrieve the details of the associated receive folder. 

**Note**

If you prefer to find a form by its shareHash, you can use the [GET /forms](#operation/getFormByShareHash) endpoint instead. 
 """,
    tags=['form_submission_handling'],
)
def get_form_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    include: Optional[str] = None,
    id: int = ...,
):
    """
    Get receive folder form by Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/forms/{id}',
    description=""" Add, update, or delete a form's parameters. This will alter how your users/customers will see and interact with the form when sending you files. 

**Notes**

*This call will **replace** your current form in its entirety.* If you want to keep any existing elements unchanged, be sure to submit the call with an element's current settings to preserve them.                           """,
    tags=['form_submission_handling'],
)
def update_form_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
    body: FormsIdPatchRequest = None,
):
    """
    Updates a form with given parameters
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notifications',
    description=""" Get a list of all the [notifications](/docs/account/06-notifications) you have access to. You can use sorting and filtering to limit the returned list.

**Notes:**
  - Authenticated user should have [notifications permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) """,
    tags=['system_notification_management'],
)
def list_notifications(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    type: Optional[Type22] = None,
    offset: Optional[int] = 0,
    sort: Optional[str] = None,
    limit: Optional[int] = 25,
    include: Optional[Include2] = None,
    action: Optional[Action1] = None,
):
    """
    Get a list of notifications
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/notifications',
    description=""" Create a new notification for a [resource](#section/Identifying-Resources) in your account. Notifications can be sent via email or webhook;

- To enable email, pass an array of email addresses to the `recipients` parameter of this call. 
- To enable webhooks, setup the webhook callback URL in your account settings via [PATCH /account](#operation/updateAccount). 

**Notes:**
  - Authenticated user should have [notifications permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions)
 """,
    tags=['system_notification_management'],
)
def add_notification(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: NotificationsPostRequest = None,
):
    """
    Create a new notification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/notifications/{id}',
    description=""" Deletes a notification. Note that deleting a notification _only_ deletes the notification &ndash; it does not delete any underlying files or folders.

**Notes:**

- You need to have the [notifications permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) to update a notification.
- You can only delete notifications owned by your user account. """,
    tags=['system_notification_management'],
)
def delete_notification_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
):
    """
    Delete a notification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notifications/{id}',
    description=""" Get the details for a notification with a specific ID number. You'll be able to review its path, triggers and who's getting the notification. 

**Notes**

- You need to have the [notifications permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) to view the detail for a notification.
- You can only retrieve notifications owned by your user account. """,
    tags=['system_notification_management'],
)
def get_notification_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
    include: Optional[str] = None,
):
    """
    Get notification details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/notifications/{id}',
    description=""" Update an existing notification. You can add additional emails or change the action or users that cause a notification to trigger. 

When updating recipient emails, make sure your `recipients` parameter contains the full list of people who should be included on the notification. If you resend the list without an existing recipient, they will be deleted from the notification emails. 

**Notes:**

- You need to have the [notifications permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) to update a notification.
- You can only change notifications owned by your user account. """,
    tags=['system_notification_management'],
)
def update_notification_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
    body: NotificationsIdPatchRequest = None,
):
    """
    Update a notification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/recipients/shares/invites/{shareId}',
    description=""" Resend invitations to one or all recipients attached to specified share. The most recent message that was sent for the share will be re-used for this email.

You can use [GET /shares/{id}](#operation/getShareById) to view the recipient list and message history for a share. Use [PATCH /shares/{id}](#operation/updateShareById) to add or remove recipients. """,
    tags=['file_share_management'],
)
def resend_invitations_for_share(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    share_id: int = Path(..., alias='shareId'),
    body: RecipientsSharesInvitesShareIdPostRequest = None,
):
    """
    Resend invitations to share recipients
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/resources',
    description=""" Delete multiple file or folder resourcess. Deleting a folder resource will also delete any resources in that folder.

**Notes:**
- Authenticated user should have [delete permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions).
- It is not possible to un-delete a deleted resource.
 """,
    tags=['file_resource_management'],
)
def delete_resources(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: ResourcesDeleteRequest = None,
):
    """
    Delete Resources
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/resources',
    description=""" Returns details for specified file/folder id or hash, including upload date, size and type. For the full list of returned properties, see the response syntax, below.

**Notes:**
- Authenticated user should have list permission.
 """,
    tags=['file_resource_management'],
)
def get_resource_info(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    resource: str = ...,
    include: Optional[str] = None,
):
    """
    Get Resource Properties
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/resources',
    description=""" Create a new empty folder at the specified path. New files can be uploaded via the [/resources/upload](#operation/uploadFile) endpoint.

**Notes:**
- Authenticated user should have modify permission.
 """,
    tags=['file_resource_management'],
)
def add_folder(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: ResourcesPostRequest = None,
):
    """
    Create a folder
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/resources/compress',
    description=""" Create a zip archive containing the files from given set of paths. Note that this can be a very slow operation if you have indicated many files should be included in the archive.

**Notes:**
- Authenticated user should have modify permission.
 """,
    tags=['file_resource_management'],
)
def compress_files(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: ResourcesCompressPostRequest = None,
):
    """
    Compress resources
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/resources/copy',
    description=""" Copies a set of exisiting files/folders (provided by an array `resources`) to the requested `parentResource` in your account.
In the `resources` array, you may specify paths pointing files/folders throughout the account, but everything will be copied to the 
root of the `parentResource`.

**Notes:**
- Authenticated user should have modify permission.
 """,
    tags=['file_resource_management'],
)
def copy_resources(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: ResourcesCopyPostRequest = None,
):
    """
    Copy resources
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/resources/download',
    description=""" Downloads a file from the server. Whenever more than one file is being downloaded, the file are first zipped into  a single file before the download starts, and the resulting zip file is named to match the `downloadArchiveName` parameter.

**NOTE**: Downloading many files at once  may result in a long delay before the API will return a response. You may need to override default timeout values in your API client, or download files individually. """,
    tags=['file_resource_management'],
)
def download(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    resources__: Resources1 = Query(..., alias='resources[]'),
    download_archive_name: Optional[str] = Query(None, alias='downloadArchiveName'),
):
    """
    Download a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/resources/extract',
    description=""" Extract the contents of a zip archive to a specified directory. Note that this can be a very slow operation.

**Notes:**
- You must have  [modify permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) to do this.
 """,
    tags=['file_resource_management'],
)
def extract_files(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: ResourcesExtractPostRequest = None,
):
    """
    Extract resources
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/resources/list',
    description=""" Returns a list of files and folders in the account. Use the `resource` query parameter to indicate the folder you wish to search in (which can be /). 

**Searching for Files and Folders**

Using the `name` parameter triggers search mode, which will search the entire directory structure under the provided `resource` for files or folders with names matching the provided `name`. This supports wildcard matching such as:

- \*Report\* would find any files or folders with "Report" in the name.
- Data\_202?-09-30.xlsx would match items such as "Data\_2020-09-30.xlsx", "DATA\_2021-09-30.xlsx", "data\_2022-09-30.xlsx" etc.
- sales\* would find any files or folders starting with the word "Sales"
- \*.csv would locate any files ending in ".csv"
- \* matches everything within the directory tree starting at your given `resource`

The search is not case-sensitive. Searching for Clients\* or clients\* or CLIENTS\*, etc. will provide identical results

If you are using the `name` parameter to run a search, the `type` parameter will be ignored by the server. """,
    tags=['file_resource_management'],
)
def list_resources(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    resource: str = ...,
    sort: Optional[str] = None,
    offset: Optional[int] = 0,
    limit: Optional[int] = None,
    type: Optional[str] = None,
    name: Optional[str] = None,
    include: Optional[str] = None,
):
    """
    Get a list of all resources
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/resources/list/{id}',
    description=""" Returns a list of files/folders for the parent resource ID. 

You can use this API call to get information about all files and folders at a specified path. By default, the API returns basic metadata on each file/folder. An optional `include` parameter forces the return of additional metadata. As with all API calls, the path should be the full path relative to the user's home directory (e.g. **/myfiles/some_folder**).

**Notes:**
- Authenticated user should have list permission.
 """,
    tags=['file_resource_management'],
)
def list_resource_contents(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
    sort: Optional[str] = None,
    offset: Optional[int] = 0,
    limit: Optional[int] = None,
    type: Optional[str] = None,
    include: Optional[str] = None,
):
    """
    List contents of folder
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/resources/move',
    description=""" Moves a set of exisiting files/folders (provided by an array `resources`) to the requested `parentResource` in your account.
In the `resources` array, you may specify paths pointing files/folders throughout the account, but everything will be moved to the root of the `parentResource`.

**Notes:**
- Authenticated user should have modify permission.
 """,
    tags=['file_resource_management'],
)
def move_resources(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: ResourcesMovePostRequest = None,
):
    """
    Move resources
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/resources/preview',
    description=""" Returns a resized image of the specified document for supported file types.

Image data returned is encoded in base64 format and can be viewed using the `<img>` element. 

```<img src='data:image/jpeg;base64' + meta.image/>```

**Notes:**
- Supported files types are `'jpg'`, `'jpeg'`, `'gif'`, `'png'`, `'bmp'`, `'pdf'`, `'psd'`, `'doc'`
 """,
    tags=['file_resource_management'],
)
def get_preview_image(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    resource: str = ...,
    size: Size = ...,
    width: Optional[int] = None,
    height: Optional[int] = None,
    page: Optional[int] = 0,
):
    """
    Preview a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/resources/upload',
    description=""" Uploads a file to a specified path, with optional support for resuming a partially uploaded existing file.
 """,
    tags=['file_resource_management'],
)
def upload_file(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    offset_bytes: Optional[int] = Header(None, alias='offsetBytes'),
    path: str = ...,
    file_size: int = Query(..., alias='fileSize'),
    resume: Optional[bool] = 'true',
    allow_overwrite: Optional[bool] = Query('false', alias='allowOverwrite'),
    file: UploadFile = ...,
):
    """
    Upload a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/resources/{id}',
    description=""" Delete a single file or folder resource. Deleting a folder will also delete all of the contents.

**Notes:**
- Authenticated user should have [delete permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions).
- There is no way to un-delete a deleted resource.
 """,
    tags=['file_resource_management', 'user_operations_management'],
)
def delete_resource_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
):
    """
    Delete a Resource
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/resources/{id}',
    description=""" Returns metadata for specified file/folder path, including upload date, size and type. For the full list of returned properties, see the response syntax, below.

**Notes:**
- Authenticated user should have list permission.
 """,
    tags=['file_resource_management'],
)
def get_resource_info_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    include: Optional[str] = None,
    id: int = ...,
):
    """
    Get resource metadata
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/resources/{id}',
    description=""" Update the specified file or folder resource record's "name" parameter. The resource is identified by the numeric resource ID that is passed in as the last segment of the URI.
 """,
    tags=['file_resource_management'],
)
def update_resource_by_id(
    ev_access_token: str = Header(..., alias='ev-access-token'),
    ev_api_key: str = Header(..., alias='ev-api-key'),
    id: int = ...,
    body: ResourcesIdPatchRequest = None,
):
    """
    Rename a resource.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/shares',
    description=""" Get a list of shares that you would have access to view through the web interface. You can limit which results are returned by specifying specific types of shares you wish to view, finding things shared with a specific email address, as well as finding shares for specific folder names.


**Notes:**

- Authenticated user requires [share permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions).
- To get share objects with type send, authenticated user's role must be admin or master. """,
    tags=['file_share_management'],
)
def list_shares(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    offset: Optional[int] = None,
    limit: Optional[int] = 100,
    scope: Optional[Scope] = None,
    sort: Optional[Sort] = None,
    type: Optional[Type25] = None,
    include: Optional[str] = None,
    name: Optional[str] = None,
    recipient: Optional[str] = None,
    message: Optional[str] = None,
    username: Optional[str] = None,
    search: Optional[str] = None,
):
    """
    Get a list of shares
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/shares',
    description=""" Creates a new share object for the given path in your account. We support three types of shares:

  - A **shared folder** allows you to let outside parties access a folder in your account (including any files and nested subfolders) using just a link. Shared folders can be restricted; e.g. with an expiration date, password, download-only, etc. Shared folders are 'live'; if someone makes a change to a file in your shared folder, it will be immediately reflected in your account, and vice-versa.
  - A file **send** lets you send one or more files via an easy download link. File sends are different than shared folders because file sends are 'point in time' -- the recipient will get the files as you sent them. If you later make a change to the source file, it will not be updated for the recipient.
  - A **receive** folder lets you receive files into your account. You can either send users a link, or optionally [embed a customized form](/docs/account/05-file-sharing/05-upload-widget) on your website.
  
**How to send files from your computer using the API**:

In order to use the API to send files which are not already stored in your account, you'll need to follow a three-step process:

1. Use the [POST /shares](#operation/addShare) endpoint to set up your send, including password, recipients, expiration, etc. You must include **upload** among the permissions in the `accessMode` and set the `sendingLocalFiles` parameter to **true**. The response that is returned will include a "meta" attribute, which contains an **accessToken** attribute. This new access token is valid only for the send.
2. Use the [POST /resources/upload](#operation/uploadFile) endpoint to upload your files to the send you've created. The "/" path represents the root of the share, not your home directory. **You must send the access token that you received from the first step in the `ev-access-token` header**
3. Use the [POST /shares/complete-send/{id}](#operation/completeDirectSend) endpoint to indicate that you have finished uploading files to your send. This will trigger the system to remove the **upload** permission from the share and send any invitation emails you set up in the first step of the process. **You must send YOUR access token in the `ev-access-token` header, not the temporary access token**

**Setting the Share Permissions**

Only 5 different combinations of permissions are valid for the `accessMode` object:

- **Upload Only**: This allows share visitors to upload to a share but do nothing else to the contained files. To use this mode, set `upload` to **true** and all other permissions to **false**
- **Download Only**: This allows share visitors to download files from a share but do nothing else to the contained files. To use this mode, set `download` to **true** and all other permissions to **false**
- **Upload and Download**: This allows share visitors to upload new files to the share or download files within the share, but not make any other changes to the share contents. To use this mode, set `upload` and `download` to **true** and set both `modify` and `delete` to **false**
- **All but Delete**: This allows share visitors to make any changes to the contents of a share except deleting files. To use this mode, set `upload`, `download`, and `modify` to **true** and set `delete` to **false**
- **Full Access**: This allows share visitors to make any changes to the contents of a share. To use this mode, set all 4 permissions `upload`, `download`, `modify`, and `delete` to **true**

Any other combination of permissions provided as the `accessMode` will be rejected as a bad request.

**Notes:**

Authenticated user requires [share permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions). """,
    tags=['file_share_management'],
)
def add_share(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: SharesPostRequest = None,
):
    """
    Creates a share
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/shares/complete-send/{id}',
    description=""" After uploading the file(s) to be sent, this method will trigger invitation emails and finish the send files setup. If you are not sending files from your own computer in a send, you will not need this step.
  
**How to send files from your computer using the API**:

In order to use the API to send files which are not already stored in your account, you'll need to follow a three-step process:

1. Use the [POST /shares](#operation/addShare) endpoint to set up your send, including password, recipients, expiration, etc. You must include **upload** among the permissions in the `accessMode` and set the `sendingLocalFiles` paramter to **true**. The response that is returned will include a "meta" attribute, which contains an **accessToken** attribute. This new access token is valid only for the send.
2. Use the [POST /resources/upload](#operation/uploadFile) endpoint to upload your files to the send you've created. The "/" path represents the root of the share, not your home directory. **You must send the access token that you received from the first step in the `ev-access-token` header**
3. Use the [POST /shares/complete-send/{id}](#operation/completeDirectSend) endpoint to indicate that you have finished uploading files to your send. This will trigger the system to remove the **upload** permission from the share and send any invitation emails you set up in the first step of the process. **You must send YOUR access token in the `ev-access-token` header, not the temporary access token**
 """,
    tags=['file_resource_management', 'file_share_management'],
)
def complete_direct_send(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
):
    """
    Complete send files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/shares/{id}',
    description=""" Deactivate a share. Deactivating a share does not remove the underlying files for **shared_folder** and **receive** share types; it merely removes the access URL. Deleting a **send** share type does remove the associated files, as files that have been sent are only associated with the share, and aren't stored anywhere else in the account.

**Notes:**

- You must have [sharing permissons](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) to use this.
- You must have [admin-level access](/docs/account/04-users/01-admin-users), or you must be the owner of the specified share you wish to delete. """,
    tags=['file_share_management'],
)
def delete_share_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
):
    """
    Deactivate a share
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/shares/{id}',
    description=""" Get the details for a specific share entry. You can use the `include` parameter to also get the details of related records, such as the owning user or the resources involved in the share.

**Notes:**

- Authenticated user requires [share permission](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions).
- To get share objects with type send, authenticated user's role must be admin or master. """,
    tags=['file_share_management'],
)
def get_share_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    include: Optional[str] = None,
    id: int = ...,
):
    """
    Get a share
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/shares/{id}',
    description=""" Change the settings on an active share. Any changes made will affect all users that have access to the share. 

When updating invitees, pass the `recipients` body paramater with the full list of people who should be included on the share. If you resend the list without an existing recipient, they will be removed from the share.

**Setting the Share Permissions**

Only 5 different combinations of permissions are valid for the `accessMode` object:

- **Upload Only**: This allows share visitors to upload to a share but do nothing else to the contained files. To use this mode, set `upload` to **true** and all other permissions to **false**
- **Download Only**: This allows share visitors to download files from a share but do nothing else to the contained files. To use this mode, set `download` to **true** and all other permissions to **false**
- **Upload and Download**: This allows share visitors to upload new files to the share or download files within the share, but not make any other changes to the share contents. To use this mode, set `upload` and `download` to **true** and set both `modify` and `delete` to **false**
- **All but Delete**: This allows share visitors to make any changes to the contents of a share except deleting files. To use this mode, set `upload`, `download`, and `modify` to **true** and set `delete` to **false**
- **Full Access**: This allows share visitors to make any changes to the contents of a share. To use this mode, set all 4 permissions `upload`, `download`, `modify`, and `delete` to **true**

Any other combination of permissions provided as the `accessMode` will be rejected as a bad request.

**Notes:**

  - Authenticated user should be the owner of the specified share. """,
    tags=['file_share_management'],
)
def update_share_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
    body: SharesIdPatchRequest = ...,
):
    """
    Update a share
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ssh-keys',
    description=""" Returns a list of SSH Keys within the account. Can be filtered for a single user. """,
    tags=['ssh_key_operations'],
)
def get_s_s_h_keys_list(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    user_id: Optional[str] = Query(None, alias='userId'),
    limit: Optional[int] = None,
    offset: Optional[int] = None,
):
    """
    Get metadata for a list of SSH Keys
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ssh-keys',
    description=""" Create a new SSH Key for a user. Provide the Public Key as formatted from the ssh-keygen command (openssh format or RFC-4716 format).

If you'd prefer to let us generate your key automatically, you can log in to your account via the web portal and set up new keys via the SSH Keys page.  """,
    tags=['ssh_key_operations'],
)
def add_s_s_h_key(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: SshKeysPostRequest = None,
):
    """
    Create a new SSH Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/ssh-keys/{id}',
    description=""" Delete the specified SSH key. This will not delete or deactivate the user tied to the key. """,
    tags=['ssh_key_operations', 'user_operations_management'],
)
def delete_s_s_h_key(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: str = ...,
):
    """
    Delete an SSH Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ssh-keys/{id}',
    description=""" Return the information for a single SSH Key """,
    tags=['ssh_key_operations'],
)
def get_s_s_h_key(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: str = ...,
):
    """
    Get metadata for an SSH Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users',
    description=""" Get a list of the users in your account. There are three main types of searches you can do with this method:

1. Search for a user by username. If you provide the `username` parameter in your call, then only the user who exactly matches that username will be in the list of matches. Any other parameters are ignored.
1. Search for a user by individual filter fields (`nickname`,`email`,`role`,`status`,`homeDir`). Users in the list will be ones who match all of the filters you choose to search by. For example, you could look for users with the "admin" `role` AND `email` addresses ending in "*@acme.com". 
1. Search for a user by search string. If you provide the `search` parameter, users whose nickname OR email OR role OR homeDir match value your provide.

**Notes:**

- You must be an [admin-level user](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) to use this.
- The homeDir is the full path to the user's home directory, not a resource ID or hash. """,
    tags=['user_operations_management', 'account_settings_management'],
)
def list_users(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    username: Optional[str] = None,
    home_resource: Optional[str] = Query(None, alias='homeResource'),
    nickname: Optional[str] = None,
    email: Optional[str] = None,
    role: Optional[str] = None,
    status: Optional[int] = None,
    search: Optional[str] = None,
    offset: Optional[int] = None,
    sort: Optional[str] = None,
    limit: Optional[int] = None,
    include: Optional[str] = None,
):
    """
    Get a list of users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/users',
    description=""" Adds a new user to the account. The user may be configured as an admin or standard user, and (if a standard user) may be assigned a restricted [home directory](/docs/account/04-users/00-introduction#setting-the-user-s-home-directory) and restricted [permissions](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions). 

**Notes:**

- You must be an [admin-level user](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) to use this. """,
    tags=['user_operations_management'],
)
def add_user(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: UsersPostRequest = None,
):
    """
    Create a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/users/{id}',
    description=""" Delete a user from the account. Deleting a user does **NOT** delete any files from the account; it merely removes a user's access. Aternatively, locking a user via the [PATCH /users/{id}](#operation/updateUser) will keep the user in your account, but make it unable to log in. 

Resources and shares owned by the deleted user will be owned by the master user after the deletion.

**Notes:**
 
- You must have [admin-level access](/docs/account/04-users/01-admin-users) to delete a user.
- The primary owner of the account cannot be deleted.
 """,
    tags=['user_operations_management', 'account_settings_management'],
)
def delete_user(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
):
    """
    Delete a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{id}',
    description=""" Get the details for a specific user. You can use the `include` parameter to also get the details of related records, such as the account or the home directory.

**Notes:**

- You must have [admin or master](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) access to use this. """,
    tags=['user_operations_management'],
)
def get_user_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    include: Optional[str] = None,
    id: int = ...,
):
    """
    Get info for a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/users/{id}',
    description=""" Updates the settings for the user. Note that the unique key for this API call is our internal ID, and _not_ the username, as the username can be changed.

In the request body, you should only send the parameters for values that you wish to change for the user.

**Notes:**

- You must have [admin or master](/docs/account/04-users/00-introduction#managing-user-roles-and-permissions) access to edit other users. If you have user-level access, you can only update your own user settings.
- You cannot edit a master user with this method. """,
    tags=['account_settings_management', 'user_operations_management'],
)
def update_user(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
    body: UsersIdPatchRequest = None,
):
    """
    Update a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/webhooks',
    description=""" Returns a list of Webhooks. By default, this will return metadata on all Webhooks within the account.  """,
    tags=['webhook_operations_management'],
)
def get_wehooks_list(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    include: Optional[str] = None,
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[int] = None,
):
    """
    Get Webhooks List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/webhooks',
    description=""" Create a new Webhook on your account. Creating a Webhook will require an endpoint URL, a path, what events should trigger a webhook, and what request version to use.  """,
    tags=['webhook_operations_management'],
)
def add_webhook(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    body: WebhooksPostRequest = None,
):
    """
    Add A New Webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/webhooks/regenerate-token/{id}',
    description=""" This endpoint will allow you to regenerate the security token for a webhook if you believe its been compromised in any way.  """,
    tags=['user_session_logging'],
)
def regenerate_webhook_token(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: str = ...,
):
    """
    Regenerate security token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/webhooks/resend/{activityId}',
    description=""" This endpoint will allow you to resend a webhook that was previously sent. Resent webhooks will send exactly the same as the original webhook with the exception of the sent timestamp. Activity IDs can be retrieve from the webhook logs in your account or via GET /activity/webhooks """,
    tags=['webhook_operations_management'],
)
def resend_webhook_activity_entry(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    activity_id: str = Path(..., alias='activityId'),
):
    """
    Resend a webhook message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/webhooks/{id}',
    description=""" Deleted the specified webhook. This will not affect logs or any resources the webhook is connected to.  """,
    tags=['webhook_operations_management'],
)
def delete_webhook(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
):
    """
    Delete a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/webhooks/{id}',
    description=""" Returns the metadata for a specific webhook. Webhook IDs can be retrieve from GET /webhooks """,
    tags=['webhook_operations_management'],
)
def get_webhook_by_id(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    include: Optional[str] = None,
    id: int = ...,
):
    """
    Get info for a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/webhooks/{id}',
    description=""" Update the specified webhook. Updated webhooks will take effect immediately and could impact active workflows. Please be certain the webhook is not currently in use prior to updating. 

You only need to send the portions of the webhook configuration you wish to change, rather than the entire webhook object. """,
    tags=['webhook_operations_management'],
)
def update_webhook(
    ev_api_key: str = Header(..., alias='ev-api-key'),
    ev_access_token: str = Header(..., alias='ev-access-token'),
    id: int = ...,
    body: WebhooksIdPatchRequest = None,
):
    """
    Update a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
